# Homework

For backend only applicants, you should only need to deal with files in the `elixir` folder.

You will need to have postgres running.
The easiest way to install postgres is through brew:
`brew install postgres`

To start your Phoenix server:

  * Install dependencies with `mix deps.get`
  * Create and migrate your database with `mix ecto.setup`
  * Start Phoenix endpoint with `mix phx.server`

Now you can visit [`localhost:8000`](http://localhost:8000) from your browser.
You can use [`localhost:8000/graphiql`](http://localhost:8000/graphiql) to make basic graphql queries from your browser.


## Docker

If you want to run this in docker you can do so:
1. run `docker-compose build` from `/elixir` directory of the app.
2. run `docker-compose up web` from `/elixir` directory of the app to start the server.
3. run `docker-compose up test` from `/elixir` directory of the app to run the tests.


This can be particularly helpful if you are running on Windows or are having issues getting postgres or elixir running.

Note, you will have to run `docker-compose build` every time you change code.

Also if you just want to run postgres in docker, you can run `docker-compose up db` to just spin up postgres.

## Learn more

  * Official website: https://www.phoenixframework.org/
  * Guides: https://hexdocs.pm/phoenix/overview.html
  * Docs: https://hexdocs.pm/phoenix
  * Forum: https://elixirforum.com/c/phoenix-forum
  * Source: https://github.com/phoenixframework/phoenix
  * Absinthe: https://hexdocs.pm/absinthe/overview.html

## Objectives completed for the homework:
  ### 1. Wrote a new schema, queries, and mutations to add companies to the app
  - Added migrations (`mix phx.gen.migration ...`) to add Company to the mix and maintain referential integrity as well as alter existing `users` and `transactions` tables. Set following foreign key constraints on the following relationships:
    * `companies c` -> `users u` on `c.id = u.company_id`
    * `companies c` -> `transactions t` on `c.id = t.company_id`
    * `users u` -> `transactions t` on `u.id = t.user_id`
  
  - Created and updated schemas + Changeset validation for each table
    * Updated: Transaction & User
    * Created: Company (fields include - autogenerated PK `:id`, `:name`, `:credit_line`, `:available_credit`, `timestamps()`)
    * This includes schema files in `homework_web` that are accesses through `GraphiQL`
  
  - Created new context `Homework.Companies` with the following functions:
    * list_companies/1
    * get_company!/1
    * create_company/1
    * update_company/2
    * delete_company/1
    * change_company/2

  - Created additional context `Homework.CompanyTransactions` to handle calculation of `available_credit` when a txn is created. This seemed like a more efficient way of keeping track of that field instead of using `Repo.aggregate/3` everytime.   Functions include:
    * create_companyTransaction/1
      - added validation to verify that company has sufficient available balance
    * list_companyTransactions/1 - list transactions per specified company
    * calculate_credit/2 - renturns tuple containing new `credit_line` & `available_credit` after creating a transaction. Amount is calculated based on if the transaction is `credit` or `debit`. Only used in the create_companyTransaction/1 function
  
  - Added `Company` resolver and updated the `User` and `Transaction` resolvers
    * Potential security risk here with a user trying to get data from another company
    * I don't like that the front end is able to update and delete companies and transactions
  
  ### 2. Seeded the database using `seeds.exs`. Uses `create_companyTransaction` to update companies availalbe balance. Generates the following:
  - 2 merchants
  - 2 companies
  - 2 users (1 per company)
  - 7 transactions (company1: 3 debit, 1 credit | company2: 2 debit, 1 credit)
  - Seeded database with a few records using `GraphiQL` to verify that changes to resolvers and mutations were working

  ### 3. Wrote tests for resolvers and mutations:
  - Updated tests for `User` & `Transaction` functions to include additional `Company` fields
  - created `companytransaction_test.exs` to test valid and invalid returns of `create_companyTransaction/1`
    * Includes testing for debit and credit transactions and calculating their available limits depending on which type of transaction(debit/credit) it is
  - created `companies_test.exs` to test company queries and mutations
  - Resulted in 39 successful tests with 0 failures

  ### Bonus:
  - Fixed failed test. I'm guessing that was the bug with `transactions`